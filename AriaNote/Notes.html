<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
	<title>Applied Cryptography Notes</title>
    <link rel="stylesheet" href="style.css">

    <script type="text/javascript" src="https://d3js.org/d3.v7.min.js"></script>
    <script type="text/javascript" src="oldCiphers.js" async></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-chtml.js" async></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/scrypt-js@3.0.1/scrypt.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/aes-js@3.1.2/index.min.js"></script>
    <script type="text/javascript" src="aes.js" async></script>

	<link rel="favicon" type="image/png" href="favicon.png">
</head>
<body>
<p style="width: wrap-content;float: right;">Copyright Aria Diamond 2021</p>

<h1>Applied Cryptography Notes</h1>
<hr />
<!-- Ciphers -->

<div id="oldCipherPlay" class="subelem" style="float: right; width: 20em;">

<p>Choose which cipher to use</p>

<input type="radio" id="caeser" name="oldCipherType" value="caeser" checked>
<label for="caeser">Caeser</label>
<br>

<input type="radio" id="rot13" name="oldCipherType" value="rot13">
<label for="rot13">ROT-13</label>
<br>

<input type="radio" id="rotate" name="oldCipherType" value="rotate">
<label for="rotate">Shift an arbitrary amount</label>
<br>
<div id="rotateAmtShow" hidden>
    <label for="rotateAmt">Amount of Characters to Shift</label>
    <br>
    <input type="range" id="rotateAmt" name="rotateAmt" min="0" max="26" step="1">
    </br>
</div> <!-- End div id=rotateAmtShow -->

<input type="radio" id="rndPerm" name="oldCipherType" value="rndPerm">
<label for="rndPerm">Random Permutation (only supports a-z)</label>
<br>

<input type="radio" id="vignere" name="oldCipherType" value="vignere">
<label for="vignere">Vignere (only supports a-z)</label>
<br>

<div id="mappingShow" hidden>
    <svg id="mappingSVG" width="100%" height="10em"></svg>
</div>

<hr>
<p>
<input type="radio" id="encryptOld" name="encryptDecryptOld" value="encryptOld" checked>
<label for="encryptOld">Encrypt!</label>
<input type="radio" id="decryptOld" name="encryptDecryptOld" value="decryptOld">
<label for="decrypt">Decrypt</label>
<button onClick="swapPlaintext()">Swap Plaintext/Ciphertext</button>
</p>

<p><label for="plainTextOld">Plain text to encrypt:</label> <br> <input type="textbox" id="plainTextOld" name="plainTextOld"></p>
<p><label for="cipherTextOld">Resulting cipher text:</label> <br> <input type="textbox" id="cipherTextOld" name="cipherTextOld" readOnly="true"></p>
</div> 

<!-- Lecture Notes -->

<div class="lecture">

<h2 id="classical-cryptography">Classical Cryptography</h2>
<div class="subelem">

<h3 id="probability-theory">Probability Theory</h3>
<ul>
<li><strong>Simple event:</strong> a single value (event) that can occur once within the sample space of events.</li>
<li><strong>Complex Event:</strong> a composition of simple events. This is often the complement (\(\neg\)), intersection/conjunction (\(\land\)), or union/disjunction (\(\lor\)) of events.
<ul>
<li>\(Pr(\neg E) = 1 - Pr(E)\)</li>
<li>\(Pr(E \land F) =\) sum of all events in both sample spaces.</li>
<li>\(Pr(E \lor F) \leq Pr(E) + Pr(F)\)</li>
<li>Given \(Pr[E_2] \neq 0\), then \(Pr[E_1|E_2] = \frac{Pr[E_1 \cdot E_2]}{Pr[E_2]}\)</li>
<li>Bayes Theorem: Given, \(Pr[E_2] \neq 0\), then \(Pr[E_1|E_2] = \frac{Pr[E_1] \cdot Pr[E_2|E_1]}{Pr[E_2]}\)</li>
</ul></li>
</ul>
</div> <!-- End Subelem -->

<h3 id="old-ciphers">Old Ciphers</h3>
<ul>
<li><strong>Caeser:</strong> rotate each letter 3 forward to encrypt, and 3 back to decrypt. This is a terrible algorithm.</li>
<li><strong>ROT-13:</strong> rotate each letter 13 forward/back. This is used in online forums to hide spoilers without making the information actually private.</li>
<li><strong>Shift:</strong> rotate each letter a constant arbitrary amount. This is better than caesar in that there is some randomness, but the key space is small (26).</li>
<li><strong>Random Permutation (mono-alphabetic substitution):</strong> each letter maps to a random (unique) letter. This has a larger key space (<em>26!</em>), but is vulnerable to frequency analysis.</li>
<li><strong>Poly-alphabetic Substituion:</strong> the key is a set of a few letters, and each letter of plaintext is encrypted by xoring or shifting by <em>key[plaintextIdx % len(key)]</em></li>
<li><strong>Vignere:</strong> polyalphabetic-alphabetic substition, but rotate each value <em>i</em>, where <em>i</em> is the index of the plaintext/ciphertext.</li>
</ul>
<h3 id="perfect-secrecy">Perfect Secrecy</h3>
<ul>
<li><strong>Perfect Secrecy:</strong> Having the ciphertext shares no information about the message encrypted. This means each plaintext is equally likely to be encrypted to the ciphertext.</li>
</ul>
<!-- How to break OTP when multiple messages are encrypted with the same key
- OTP: 
- c0 = k0 xor m0 if c1 = k0 xor m1
    c0 xor c1 = (k0 xor m0) xor (k0 xor m1)
    = (k0 xor k0) xor (m0 xor m1)
    = (0) xor (m0 xor m1)
    = m0 xor m1
    Use frequency analysis from here?
-->

</div> <!-- End Lecture -->
<hr />
<div class="lecture">

<h1 id="modern-cryptographic-primitives-mostly-number-theory">Modern Cryptographic Primitives (Mostly Number Theory)</h1>
<div class="subelem">

<h2 id="runtime">Runtime</h2>
<ul>
<li>Resource usage for an object of size <em>N</em> is usually a function of <em>N</em> (ex: \(log(N)\), \(N^K\), \(2^N\)).</li>
<li>For runtimes, we normally don't care about best case, but we do care about average case and worst case. Average case is important because that is what happens most of the time.</li>
<li>This is an explaination of asymptotic runtime bounds.</li>
</ul>
<h2 id="complexity-theory">Complexity Theory</h2>
<ul>
<li><strong>Turing Machines:</strong> the model of computation we can translate all current algorithms into. This allows us to determine complexity.</li>
<li>Because optimization problems are much more complex to represent in Turing Machines, and optimization and decision problems are runtime equivalent, decision problems are analyzed in place of the optimization problems.</li>
<li><strong>Language:</strong> a set of binary strings that satisfy some property. We can then take a string <em>x</em> and check if it's in <em>L</em>.</li>
<li>Complexity Classes
<ul>
<li><strong>Polynomial time algorithms:</strong> problems can be solved with poly time algorithms. This is efficient to solve on modern computers.</li>
<li><strong>NP:</strong> a potential solution can be verified in polynomial time. This technically includes poly time solution algorithms, as well as algorithms where we do not currently have a poly time solution algorithm (but we do not know if one exists).</li>
<li><strong>Bounded-Error Probabilistic Polynomial Time (BPP):</strong> (<a href="https://en.wikipedia.org/wiki/BPP_%28complexity%29">wiki</a>). It is hypothesized <em>BPP = P</em>, but there is the possibility that <em>BPP</em> is larger than <em>NP</em>.</li>
<li><strong>NP Complete:</strong> all NPC problems can reduce to all other NPC problems. These are hard and what separates modern cryptography from classical cryptograhy.</li>
</ul></li>
<li>One problem reducing to another does not mean that the other will reduce to the first.</li>
</ul>
</div> <!-- End subelem -->

<h2 id="modern-cryptography">Modern Cryptography</h2>
<ul>
<li>This is when math/proofs comes in to verify security of ciphers.</li>
<li>This has certain assumptions that provide a certain guarantee (someone cannot break this with certain resources/time constraints).</li>
<li>Security Notions:
<ul>
<li><strong>Design:</strong> specifying goals/prerequisites to chose certain tradeoffs to benefit use cases.</li>
<li><strong>Usage:</strong> look at applications of ciphers and choose what works best.</li>
<li><strong>Study:</strong> new ways to compare ciphers.</li>
</ul></li>
</ul>
<h2 id="public-key-cryptography">Public Key Cryptography</h2>
<ul>
<li>Public Key cryptography was thought not possible, and caused the revolution for modern cryptography.</li>
<li>Requirements for modern crypto systems:
<ol type="1">
<li>Efficient encryption and decryption algorithm.</li>
<li>An inefficient algorithm to break the key. We need functions in <em>NP</em>, and not <em>BPP</em>. This needs to be hard in the average case, not just worst case because attackers deal with average case.</li>
<li>We do not need perfect secrecy, as it is too inefficient to implement/use in practice.</li>
<li>We need to be able to share keys so people can communicate with those who they do not know.</li>
</ol></li>
<li><strong>Negligible Functions:</strong> functions that go towards 0 very quickly (faster than polynomial) as <em>n</em> increases. These are useful as they will not noticably affect a polynomial time algorithm. Example: \(\frac{1}{n!}, 2^{-n}\).
<ul>
<li>Mathmatical definition of negligible: \(\forall c &gt; 0, \exists n_c &gt; 0 | \forall n \geq n_c : f(n) &lt; n^{-c}\)</li>
</ul></li>
<li><strong>One Way Functions:</strong> These are easy to apply, but hard to invert. The probability that the attacker can find the interse is negligible. ex: hashes.</li>
<li><strong>Trapdoor Functions:</strong> a one way function with a trapdoor (a polynomial sized string) that makes inversion easy. The issue with this is that the inverse might not exactly be correct (such as with the squaring function, and taking the square root gives both positive and negative roots); it is non-deterministic.</li>
<li><strong>Trapdoor Permutation:</strong> a trapdoor function where the function and inverse is one to one (bijective). This might leak parts of the message.</li>
<li><strong>Hardcore Bits:</strong> given an input string, it returns a single bit output. This can be thought of as a random bit by the adversary.
<ul>
<li>The hardcore bit must be easy to compute from the message, but hard given just the trapdoor permutation (ciphertext).</li>
<li>This can be computed from a trapdoor permutation.</li>
<li>The <em>probability of a hardcore bit - 1/2</em> should be negligible (it should be computationally indistinguishable from a random bit).</li>
</ul></li>
</ul>
</div> <!-- End Lecture -->
<hr />
<!--
<div class="subelem" style="float: right; width:20em;">
<p>Greatest Common Divisor</p>

<input type="range" id="aGCD" name="aGCD" value="40" min="1">
<label for="aGCD" id="laGCD">a</label>
<br>

<input type="range" id="bGCD" name="bGCD" value="10" min="1">
<label for="bGCD" id="lbGCD">b</label>

<label for="resultGCD">GCD:</label>
<input type="textbox" id="resultGCD" name="resultGCD" disabled="true" style="width:2em;">

</div>  End GCD -->

<!-- Lecture Notes -->

<div class="lecture">

<h1 id="building-public-key-cryptography-from-number-theory-primitives">Building Public Key Cryptography from Number Theory Primitives</h1>
<h2 id="hardness-assumptions-for-cryptographic-primatives">Hardness Assumptions for Cryptographic Primatives</h2>
<ul>
<li><strong>One-way functions:</strong> these are hard to invert.</li>
<li><strong>Trapdoor fucntions:</strong> again hard to invert (unless you have a trapdoor functions).</li>
<li><strong>Hard Core Predicates:</strong> hard to guess.</li>
<li>Proving a one way function is in <em>NP</em>/hard means \(P \neq NP\). Thus while we cannot have a proof, we have confidence from evidence that the problem is hard.</li>
<li>The main hard problems are: Factoring composite integers (RSA) and logarithms modulo primes (Diffie-Hellman and Elliptic curves).</li>
</ul>
<h2 id="algorithmic-number-theory">Algorithmic Number Theory</h2>
<ul>
<li><strong>Number Theory:</strong> a branch of pure mathmatics concerned with the properties of integers.</li>
<li><strong>Algorithmic Number theory:</strong> study of algorithms working through number theoretic computations.</li>
<li>This uses <em>n</em> as the length of the binary representation of an integer.</li>
<li>Integers: <em>Z</em>, Positive Integers: <em>N</em></li>
<li><em>a divides b = a|b</em> (\(\frac{b}{a}\)) if \(\exists c \in N: a \cdot c = b\). If \(a \neq 1\ and\ a\neq b\), <em>a</em> is non-trivial.</li>
<li><strong>Fundamental Theorem of Arithmetic:</strong> every integer larger than 1 can be uniquely expressed as the product of prime powers.</li>
<li><strong>Relatively Prime/Coprime:</strong> <em>a</em> and <em>b</em> where <em>gcd(a, b)=1</em></li>
</ul>
<div class="subelem">

<h1 id="my-notes-in-this-section-are-not-great-and-i-would-not-trust-them-at-the-moment">My notes in this section are not great, and I would not trust them at the moment.</h1>
<h2 id="euclidean-gcd">Euclidean GCD</h2>
<pre><code>// a &gt;= b
function gcd(a, b) {
    if (b|a) {
        return b
    }
    return gcd(b, a mod b)
}</code></pre>
<ul>
<li>\(b_{i+2} \leq \frac{b_i}{2}\). This means every two recursions, the size of <em>b</em> halves.</li>
<li>There are no more than <em>2|b|-2</em> recursive calls.</li>
</ul>
<h3 id="extended-euclidean-gcd">Extended Euclidean GCD</h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">Wiki psuedocode</a></li>
<li>There exist unique \(ax+by=gcd(a, b)\) where \(x, y \in Z\).</li>
<li>This runs in polynomial time with respect to b.</li>
<li>The extended GCD allows us to get the inverse. Inverse: \(b \cdot c = 1 mod\ n \rightarrow c=b^{-1} mod\ n-1\).</li>
<li><em>a</em> is invertible <em>mod n</em> if and only if <em>a</em> and <em>n</em> are coprime (gcd is 1).</li>
</ul>
<pre><code>// returns (d, x, y) where
// d = gcd(a, b)
// xa + yb = d
function egcd(a, b) {
    if (b|a) {
        return (b, 0, 1)
    }
    q = a / b
    r = a - q * b // 0 &lt;= r &lt; b
    (d, x&#39;, y&#39;) = egcd(b, r) // bx&#39;+ry&#39;=d
    return (d, y&#39;, x&#39;-y&#39;q)
}</code></pre>
<h2 id="inverses">Inverses</h2>
<pre><code>// given gcd(a, n) == 1
// (d, x, y) = egcd(a, n)
// (a * d) mod n = 1
function inverses(a, n) {
    (d, x, y) = egcd(a, n)
    if (d != 1) {
        return &quot;fail&quot;
    }
    return x
}</code></pre>
<h2 id="modular-exponentiation">Modular Exponentiation</h2>
<ul>
<li>\(a^b\ mod\ n = (a^{\frac{b}{2}})^2\ mod\ n\) if <em>b</em> is even or \(a^b\ mod\ n = a(a^{\frac{b-1}{2}})^2\ mod\ n\) if <em>b</em> is odd. This can be computed recursively for efficient modular exponentiation. This is called square and multiply.</li>
</ul>
<pre><code>function SquareAndMultiply(a, b, n) {
    if (b == 1) {
        return a
    }
    if (b % 2 == 0) { // b is even
        t = SquareAndMultiply(a, b/2, n)
        return (t*t) % n
    } // else
    t = SquareAndMultiply(a, (b-1)/2, n)
    return (a*t*t) % n
}</code></pre>
</div> <!-- End sketchy section -->

<h2 id="groups">Groups</h2>
<ul>
<li><strong>Group:</strong> a set of elements and a binary operation over elements that satisfies certain properties.
<ul>
<li><strong>Closure:</strong> \(\forall a, b \in G: f(a, b) \in G\)</li>
<li><strong>Identity:</strong> \(\exists e \in G: \forall a : f(a, e) = a\). There is only one identity element for each group.</li>
<li><strong>Inverse:</strong> \(\forall a \in G: \exists b \in G: f(a,b) = e\). There is only one inverse for each element in the group.</li>
<li><strong>Associativity:</strong> \(\forall a, b, c \in G: f(f(a, b), c) == f(a, f(b, c))\)</li>
</ul></li>
<li>To be an abelian group, commutativity (\(\forall a, b \in G: f(a, b) == f(b, a)\)) must also hold.</li>
<li>Groups are good to work with, so we can restict the set of elements or the operation to create a group.</li>
<li>For finite groups, there must be a cycle with respect to the operation and output given inputs.</li>
</ul>
<h3 id="group-exponentiation">Group Exponentiation</h3>
<ul>
<li><strong>Z<sub>N</sub>*:</strong> A group with the set of integers from <em>1</em> to <em>N - 1</em> with the property that all elements are relatively prime to <em>N</em> and the operation of multiplication mod <em>N</em>. This is an abelian group.</li>
<li><strong>Euler's Totient:</strong> \(\Phi(N) = (p-1)(q-1)\), where <em>p</em> and <em>q</em> are distinct primes. Euler's Totient actually provides the cardinality of the set in the group <em>Z<sub>N</sub>*</em>.</li>
<li>Using the Chinese Remainder Theorem, we see that that the cross product of <em>Z<sub>p</sub>*</em> and <em>Z<sub>q</sub>*</em> is an isomorphism of <em>Z<sub>N</sub>*</em>. This property is very important because it will allow us to invert the operation we did to encrypt data.</li>
<li><em>f</em> (the isomorphism from <em>Z<sub>N</sub>*</em> to <em>Z<sub>p</sub>*</em> times <em>Z<sub>q</sub>*</em>) and it's inverse the values for RSA (where <em>e = f</em>, and <em>d = f<sup>-1</sup></em>).</li>
</ul>
<h1 id="cryptographic-primitives-from-number-theory">Cryptographic Primitives from Number Theory</h1>
<ul>
<li>We can use reductions to have confidence in security algorithms because if the primative secure, then the algorithm is secure (provided the implementation is correct).</li>
<li>A very <a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ">useful video</a> to explain the entire process of constructing secure public key cryptography.</li>
</ul>
<div class="subelem">

<h1 id="rsa">RSA</h1>
<p><a href="https://people.csail.mit.edu/rivest/Rsapaper.pdf">The paper</a></p>
</div> <!-- End Subelem -->

</div> <!-- End Lecture -->
<hr />
<div class="lecture">

<h1 id="randomness">Randomness</h1>
<ul>
<li>Generating true randomness still usually deals with physical processes (coin tosses, dice, etc).</li>
<li><strong>Bais:</strong> the odds of getting each output are not equal. In cryptographic applications, small biases can cause attacks.</li>
<li><strong>Correlation:</strong> a relation between strings, such as a short period.</li>
<li><strong>Pseudo-randomness:</strong> a deterministic algorithm that takes a truly random string and outputs a longer string that is a transformation of the random string and looks random (even if it is not).</li>
<li>Non-secure pseudo-random generators. These pass <em>certain</em> (but not all) statistical tests, but fail next-bit predictions.
<ul>
<li>LCGs: ex: <em>x<sub>1</sub> = 3 * x<sub>0</sub> + 7</em></li>
<li>LFSRs: ex: <em>x<sub>1</sub> = ROTL(x<sub>0</sub>, 3) ^ ROTR(x<sub>0</sub>, 7) ^ ROTL(x<sub>0</sub>, 11) ^ ROTR(x<sub>0</sub>, 8)</em></li>
</ul></li>
<li>Requirements for modern cryptographic generators. Having one implies the other.
<ul>
<li>An adversary in polynomial time cannot show a statistical test that fails.</li>
<li>An adversary cannot predict the next bits in polynomial time given previous bits.</li>
</ul></li>
<li><strong>Computational Indistinguishability:</strong> given random variables <em>X</em> and <em>Y</em>, they are computationally indistinguishable if for any efficient algorithm, the difference of the probabilities for getting a value is negiligible.</li>
<li><strong>Turing Test:</strong> given two opaque box source: by asking questions, can you determine which source is the human, and which is AI? This is expanded to cryptographic use by giving an adversary an oracle that they are asked to differentiate between a PRNG/PRF/PRP/ciphertext and a random generator/function/permutation/string. A scheme is secure if the probability of the adversary guessing which source a string came from is <em><sup>1</sup>/<sub>2</sub> + a negligible amount</em> in polynomial time.</li>
</ul>
<h2 id="psuedo-random-generators">Psuedo-Random Generators</h2>
<ul>
<li><strong>Generator:</strong> takes input of size <em>n</em>, and stretches it to a longer string <em>m</em>, where \(m \geq n + 1\). Either of next-bit or statistical tests (having one implies the other) must pass for a generator to be pseudo-random.
<ul>
<li><strong>Next-Bit Test:</strong> It must be efficient given <em>m - 1</em> bits, an adversary cannot predict the <em>m</em><sup>th</sup> bit with more than <em>1/2 + negligible probability</em>.</li>
<li><strong>Statistic test:</strong> The generator must be computationally indistinguishable from a random value.</li>
</ul></li>
<li>Generating cryptographically secure pseudo-random generators is strongly related to the hardness of inverting one-way functions. In practice, these number theoretic guarantees are stronger than we need (and not efficient), so we use slightly weaker constructions.</li>
<li>There exists a pseudorandom generator <em>G</em>, if and only if there is a one way function <em>F</em>. These are the same (<em>G=F</em>).
<ul>
<li>If <em>F</em> is not a one-way function, we can predict the next bits of the pseudorandom generator by inverting <em>F</em>.</li>
<li><em>G(seed) = F(s) ++ HC(s)</em> (<em>++</em> is concatenate), where <em>HC</em> is hard-core predicate. Because <em>HC</em> predicates are hard to determine given <em>F(s)</em> (and easy with <em>s</em>), this is pseudo-random.</li>
</ul></li>
<li>With a pseudorandom generator, we can create something similar (but slightly weaker) than OTP with using <em>G(key)</em> to create a string that is <em>messageLen</em> long to xor with the plaintext. The seed can only be used to encrypt one message, otherwise secrecy is lost.</li>
<li><strong>Computational Secrecy:</strong> a adversary with an efficient algorithm cannot break the scheme (get any information about the plaintext) with more than a negligible probability in a certain amount of time (poly time). This is used in contrast to perfect secrecy (this has caveats of negligible probabality and poly time).</li>
</ul>
<h2 id="pseudo-random-functions">Pseudo-Random Functions</h2>
<ul>
<li>Random functions create uniform and independent output strings given an input string, but in practice they are too expensive.</li>
<li><strong>Pseudo-random Functions:</strong> take a short random key and input string, then output a string that looks random to a polynomial time adversary. The key is the only randomness, meaning the key must be random and secret from the adversary. This must be computationally indistinguishable from a random function for the same key if an adversary can see polynomially many outputs, and even choose the inputs for them.</li>
<li><strong>Oracle:</strong> an opaque box that outputs a value given inputs given by the adversary. The output can be either from the random function or the pseudo-random function, and the adversary has to guess.</li>
<li>A pseudo-random function is good if the adversary cannot predict whether it is random or pseudo-random given an oracle with more than a negligible advantage.</li>
<li>Pseudo-random functions seem more powerful than a pseudo-random generator, but it is more expensive, and harder to build. PRFs can also be constructed by PRGs using a binary tree expansion, then choosing the outputs according to the input string.</li>
<li>Pseudo-random functions exist if and only if a pseudo-random generator exists. This means a pseudo-random function exists if and only if a one-way function exists.</li>
</ul>
<h2 id="pseudo-random-permutations">Pseudo-Random Permutations</h2>
<ul>
<li>Similar to PR functions, these map a random key and input string to an output string. However, this has the requirement that these are one-to-one (this is important for encryption/decryption correctness).</li>
<li>A pseudo-random permutation exists if and only if a pseudo-random function exists.</li>
<li><strong>Feistel transform:</strong> given a pseudo-random function <em>F</em>, an input <em>(L, R)</em> such that the length of <em>L</em> and <em>R</em> are the same, returns <em>(L', R')</em>. All Feistel Transformations are permutations. This is used in DES.
<ul>
<li><em>L' = R</em> and <em>R' = L xor F(k, R)</em></li>
</ul></li>
<li>The Feistel Transform done 4 times is very strong (even with oracles for <em>O</em> (pseudo-random function and random function) and <em>O'</em> (inverse of pseudo-random function and inverse of random function).</li>
<li>Rounds of Feistel Transformations:
<ul>
<li><strong>Round 1:</strong> \((L, R), F(k, R) \rightarrow (L', R') = (R, L\ xor\ F(k, R))\). The adversary can see if the oracle returns from the Feistel Transform and not random function because <em>L' = R</em>, where <em>R</em> was an input known by the adversary.</li>
<li><strong>Round 2:</strong> The adversary queries <em>(A, B)</em> and <em>(C, B)</em> and gets <em>(U', V')</em> and <em>(S', T')</em> from the oracle. <em>U' xor A = F(k, B) = S' xor C</em>, which the adversary can check with the oracle for <em>U' xor A = S' xor C</em> (values the adversary knows).</li>
<li><strong>Round 3:</strong> By now, the outputs are dependent on the inputs of both sides, and is thus pseudorandom (provided <em>F</em> is pseudo-random).</li>
<li><strong>Round 4:</strong> This is very strong (even with oracles for <em>O</em> (pseudo-random function and random function) and <em>O'</em> (inverse of pseudo-random function and inverse of random function)).</li>
</ul></li>
<li><em>Enc(k, m) = (r, F(k, r) xor m)</em>, where <em>r</em> is random. <em>Dec(k, (c1, c2)) = F(k, c1) xor c2</em>. This is better in terms of computational secrecy than the pseudo-random generator construction. The key can be used for multiple messages.</li>
</ul>
<h2 id="symmetric-encryption">Symmetric Encryption</h2>
<ul>
<li>We want two main properties:
<ul>
<li><strong>Correctness:</strong> we should be able to decrypt the ciphertext and get the correct message (given the correct inputs) with a very high probability (<em>1 - negligible</em>, in the case of failure).</li>
<li><strong>Secrecy:</strong> an adversary cannot get <em>any</em> information about the message from the ciphertext except with negligible probability. The adversary's resources and time constraints need to be noted, as well as what types of attacks they can do (see below).</li>
</ul></li>
<li><strong>Message Indistinguishability (IND):</strong> the adversary knows the algorithm. When predicting an oracle, the adversary (with an efficient algorithm) can only be better than <em><sup>1</sup>/<sub>2</sub></em> by a negligible amount. This is also known as EAV (security against eavsdroppers).</li>
<li><strong>IND-KPA:</strong> known plaintext attacks. The adversary can only see plaintexts/ciphertexts encrypted by the victims, but not influence the plaintext choices.</li>
<li><strong>IND-CPA:</strong> adversary can perform chosen plaintext attacks. The adversary can influence the plaintexts encrypted. This is the most practical and easiest to run.</li>
<li><strong>IND-CCA:</strong> adversary can perform chosen ciphertext attacks.</li>
<li>Strengths: <em>IND &lt; IND-CPA &lt; IND-CCA</em>.</li>
</ul>
</div> <!-- End Lecture -->
<hr />
<div class="subelem" style="float: right; width: 20em;">

<h4 id="aes">AES</h4>
<p>Choose a mode of Operation:</p>

<input type="radio" name="AESType" value="AESECB" checked>
<label for="AESECB">ECB</label>
<br>
<input type="radio" name="AESType" value="AESCBC">
<label for="AESCBC">CBC</label>
<br>
<input type="radio" name="AESType" value="AESOFB">
<label for="AESOFB">OFB</label>
<br>
<input type="radio" name="AESType" value="AESCTR">
<label for="AESCTR">CTR</label>
<br>

<hr> <!-- Password and Key Derivation -->

<p><label for="passwordAES">Password:</label> <br> <input type="textbox" id="passwordAES"></p>
<p><label for="keyAES">Derived Key:</label> <br> <input type="textbox" id="keyAES" readOnly="true"></p>
<hr> <!-- Encrypt actual plaintext -->

<p><label for="plaintextAES">Plaintext to Encrypt</label> <br> <input type="textbox" name="plaintextAES" id="plaintextAES"></p>
<p><button onclick="aesEncipher()">Encrypt!</button></p>

<p>This encrypts the same first 16 bytes 4 times to show the difference between different encryption modes and how the same block changes when encrypted at different states.</p>
<p><label for="ciphertext0AES">Encrypted Block 0</label> <input type="textbox" id="ciphertext0AES" name="AESEncBlock" readOnly="true"></p>
<p><label for="ciphertext1AES">Encrypted Block 1</label> <input type="textbox" id="ciphertext1AES" name="AESEncBlock" readOnly="true"></p>
<p><label for="ciphertext2AES">Encrypted Block 2</label> <input type="textbox" id="ciphertext2AES" name="AESEncBlock" readOnly="true"></p>
<p><label for="ciphertext3AES">Encrypted Block 3</label> <input type="textbox" id="ciphertext3AES" name="AESEncBlock" readOnly="true"></p>
</div>

<div class="lecture">

<h1 id="block-ciphers-and-symmetric-cryptography">Block Ciphers and Symmetric Cryptography</h1>
<h2 id="ind-cma">IND-CMA</h2>
<ul>
<li><strong>Indistinguishability in the presence of chosen message attack (IND-CMA):</strong> The same as chosen plaintext attacks. The adversary is allowed to query the oracle multiple times before and use that knowledge with the challenge. This type of attack can break <strong>any</strong> deterministic encryption scheme. The construction of a symmetric key cipher from PRGs is broken by this, but the PRF construction is secure. This is why we have IVs.</li>
<li><strong>Simulation:</strong> a cryptography proof concept that replaces secret information (a key) in a way that it is computationally indistinguishable from using the key.</li>
<li><strong>Adaptive IND-CMA:</strong> an attacker can query the oracle more after seeing the challenge ciphertext. This is decently practical in real life (about as practical as normal IND-CMA). The PRF construction is still secure under this attack.</li>
</ul>
<h2 id="block-ciphers">Block Ciphers</h2>
<ul>
<li><strong>Block Cipher:</strong> a permutation that takes a key (usually 128-256 bits) and message and outputs a ciphertext in block (usually around key size) increments. The permutation is public, and only the key is private.</li>
<li>Unlike pseudo-random permutations, we have fixed key lengths. This makes block ciphers more restricted than general symmetric cryptography, and slightly changes their security notions because we cannot have asymptotic notations of algorithms, but because keys are fixed length, there is only so many options. This causes us to use 2 to a large power (currently <em>2<sup>100</sup></em>) as a good metric for security.</li>
<li>Block ciphers are (<em>t</em>, <em>ε</em>)-secure if for an algorithm that runs in <em>t</em> time, the adversary can only distinguish from a random string with less than <em>ε</em> probability.</li>
<li><strong>Substitution/Permutation Networks:</strong> (AES) the code representation is pretty small, but the input to output mapping is very large, and should look random.
<ul>
<li><strong>Confusion-Diffusion:</strong> the block is separated into much smaller blocks that are each operated on. This allows each of the smaller blocks can be encoded as random strings (S-boxes) (confusion). The output bits are permuted and mixed (diffusion). This is done multiple times (rounds) to truly mix everything.</li>
<li>Between each round, a sub key derived from the daddy key (via a key scheduler) is xored with intermediate output of a round. <!-- Daddy key and submissive keys. But what about brats? --></li>
<li>Invertibility of S-boxes: how easy is it to create the inverse</li>
<li><strong>Avalanche Effect:</strong> the result of an output bit exponentially grows depending on the input bits each round. For example, the first round, the output bit is dependent on one input bit, then the next round, the output bit is based on the two input bits (then four input bits etc).</li>
</ul></li>
<li><strong>AES:</strong> a substition permutation network with 128 bit blocks and 128 bit keys with 10 rounds, 192 bit key with 12 rounds, and 256 bit with 14 rounds. There is 16 bytes of state derived from the key.</li>
<li><strong>Feistel Networks:</strong> (DES) this is equal to substitution networks at low levels (S-boxes, mixing permutations, key scheduling), but different high level structure. This aims to create an invertible function from non-invertible functions.</li>
<li><strong>DES:</strong> 16-round Feistel network with 64 bit block size and 56 bit key length. Each subkey is 48 bits (with 24 bits from each of the left and right 28 bits of the key). These S-boxes are actually stronger than random values.</li>
<li><strong>3-DES:</strong> runs DES 3 times, increasing computation time, with only a 1.5 times improvement in security. This is currently enough to be unbreakable, but it is much slower than AES, so not worth it.</li>
</ul>
<h2 id="cryptanalysis-of-block-ciphers">Cryptanalysis of Block Ciphers</h2>
<ul>
<li><strong>Exhaustive:</strong> try every single key. For DES and AES, this is still the fastest way to break these schemes.</li>
<li><strong>Meet in the Middle:</strong> This breaks 2DES in marginally longer time than DES. Query the oracle on both sides (<em>F</em> and <em>F<sup>-1</sup></em>) and try to find values that are the same. This can also be used with block ciphers by starting with the plaintext and the ciphertext, and doing half the rounds on the plaintext, and half the rounds on the ciphertext (as done <a href="https://eprint.iacr.org/2010/168.pdf">here</a>).</li>
<li><strong>Differential:</strong> encrypt multiple plaintexts with either similar plaintexts or similar keys (change just a couple of bits) and see how much the output changes. For a random output, random values should be produced, but bad ciphers will not have changes propagating through the entire output.</li>
<li><strong>Linear:</strong> this requires only known plaintext/ciphertext pairs (not chosen plaintext), and can recover the key from bias between input and output based on xor similarities.</li>
</ul>
<h2 id="modes-of-operation">Modes of Operation</h2>
<ul>
<li>This is how to encrypt more than just block sized bits of data. This does this by expanding on the construction of pseudo-random functions.</li>
<li><strong>Electronic Code Book (ECB):</strong> each block is encrypted with the same key and ciphertexts are contcatenated. This is deterministic, so it does not satifsy IND-CMA. Encrypting the same blocks multiple times produces the same ciphertext (which depdending on the use can be bad).</li>
<li><strong>Cipher Block Chaining (CBC):</strong> a probabilistic mode (satisfies IND-CMA if the function is pseudo-random). The IV is initially provided, then at each block, the message is xored with the IV, then encrypted. The output block is then used as the IV for the next block. This does not allow for parallelism.</li>
<li><strong>Output Feedback Mode (OFB):</strong> the IV is put through the encryption algorithm, then this output is used for both the IV of the next block, as well as xored with the message to create the ciphertext. This is a stream cipher, but you do not need the message before you can start building randomness.</li>
<li><strong>Counter (CTR):</strong> a fully parallelizable stream cipher. This takes an IV, which is put through the encryption algorithm then xored with the message. <em>IV<sub>n</sub> = IV<sub>0</sub> + index</em> for block <em>n</em>. This allows out of order encryption/decryption.</li>
<li><strong>Galoa-Counter Mode (GCM):</strong> the best?</li>
</ul>
</div> <!-- End Lecture -->
<hr />
<div class="lecture">

<h1 id="message-authentication">Message Authentication</h1>
<ul>
<li>Because we cannot prevent authentication attacks, we at least want to be able to detect these attacks. In particular, we want:
<ul>
<li><strong>Message Integrity:</strong> We know that the message recieved is the same as the message sent.</li>
<li><strong>Message Authenticity:</strong> We know that it was the person who we think it was who sent the message (not an impersonator).</li>
<li>*This does not cover replay and side-channel attacks.</li>
</ul></li>
<li><strong>Tag:</strong> a hash or the like of the message, appended to the end. These only need to be 100-200 bits.</li>
<li><strong>Existential Unforgeable for CMA:</strong> the adversary cannot create a valid tag for a message (not from the oracle) in polynomial time with more than negligible success. The adversary can query an oracle with polynomial number of messages and get their corresponding tags.</li>
<li>Message authentication cannot just be reuse of encryption algorithms (they must be explicitly designed).
<ul>
<li>If we try to use the PRG construction of an encryption algorithm, we can forge a message. The tag ends up being a second encryption of the message. We can forge this by changing both the message and tag in the same place.</li>
<li>Using ECB, if we encrypt two blocks and use them as the tags, we can do a reordering attack by swapping the messages and their tags.</li>
<li>PRFs do work! (provided <em>F</em> is pseudo-random). The tag is generated by <em>t=F(k, m)</em>, and verification is done by checking <em>t'=F(k, m')</em>. In practice, any block cipher that looks like a PRF works efficiently.</li>
</ul></li>
</ul>
<h2 id="arbitrary-length-constructions">Arbitrary length constructions</h2>
<ul>
<li>Tags for multiple blocks of the smae message must cascade into each other. This is because otherwise we can do substring, reordering, truncation, mix-and-match attacks.
<ul>
<li>Substring:</li>
<li>Reordering:</li>
<li>Truncation:</li>
<li>Mix-and-Match:</li>
</ul></li>
<li><strong>CBC-MAC:</strong> the output is only the last block, rather than outputting each block. The IV is also just 0s (meaning the output is deterministic). This is efficient if <em>F</em> is efficient, but relatively slow because it is designed for encryption.</li>
</ul>
<h2 id="collision-resistant-hash-functions">Collision-Resistant Hash Functions</h2>
<ul>
<li>Adversarial attacks try to just produce two different inputs that hash to the same value.</li>
<li>Collision-resistant: any efficient advesary cannot find two different inputs that hash to the same value with mroe than negligible probability. We want these outputs to be pseudo-random, and for the most secure (innefficient) attacks behave like random functions.</li>
<li>We can find a collision with high probability for a size of roughly one half the space of the hashes. This is because the birthday attack and gives us that all hash functions only have \(2^{\frac{|x|}{2}}\) where <em>|x|</em> is the length of the hash.</li>
<li>We can probably create an arbitrary length collision resistant function from a fixed length collision resistant function.</li>
<li><strong>Merkle-Damgaard Construction:</strong> <span class="confused">is this creation of hash functions for arbitrary length inputs from fixed input hash functions?</span></li>
<li>Most hash functions do not have private keys (either keys available to the adversary, or no keys).</li>
<li><strong>HASH and MAC:</strong> This takes a generic collision resistant hash function, which makes this existentially unforgeable under CMA.</li>
<li><strong>SHA3-MAC:</strong> This just uses the SHA-3 hash of the key concatenated with the message. This is not secure enough for just any Merkle-Damgaard construction. <span class="confused">There is a length extending attack? how?</span></li>
<li><strong>HMAC:</strong> A double hash of the message. The first hash is of the message concatenated with random strings and padding, which is then hashed again. This aims to deal with extension attacks.</li>
</ul>
<h2 id="ind-cca">IND-CCA</h2>
<ul>
<li>With random oracles, sometimes a chosen ciphertext does not map to a valid message. In this case, the oracle returns an error.</li>
<li>PRF encryption does not satisfy IND-CCA. This also applies to all block ciphers. This is broken by the attacker querying for the bits flipped of the challenge ciphertext.</li>
<li>To protect against IND-CCA, we then add a tag to the ciphertext, so if the ciphertext does not match the tag (ie. if the bits were flipped), then verification fails. This also requires that the encryption algorithm is IND-CMA secure.</li>
</ul>
<h2 id="threats">Threats</h2>
<ul>
<li>Replay:</li>
<li>Re-ordering:</li>
<li>Reflection:</li>
<li>Solution:
<ul>
<li>Timestamps: If we send (ts, c, t) where <em>t = H<sub>k</sub>(ts | c)</em>, this is protected against eavesdroppers, integrity attacks, replay, re-ordering, and reflection.</li>
<li>Session Tokens:</li>
</ul></li>
</ul>
<div class="subelem">

<h2 id="damgård-hash-function-constructions">Damgård hash function constructions</h2>
<p><a href="https://www.researchgate.net/publication/221354712_A_Design_Principle_for_Hash_Functions">The paper</a></p>
<ul>
<li><strong>Collision free:</strong> this just means that it is computationally hard to find a collision, but not that it does not exist (because the pigeon-hole principle requires collisions). Given a function <em>f</em> that can be chosen from some family of functions in polynomial time, it is hard (there is a negligible probability of success) to find <em>f(n) = f(m)</em> where \(n \neq m\).</li>
<li>This aims to create collision intractible hash functions that are also efficient.</li>
</ul>
</div> <!-- End Subelem -->

</div>
<div class="lecture">

<h2 id="formal-definition-of">Formal definition of</h2>
<ul>
<li>Key Generation: returns public key and secret key (2 keys versus 1 for symmetric).</li>
<li>The encryption algorithm takes random bits.</li>
<li>Decryption is usually deterministic, but can be probabilistic (which means negligible failure).</li>
<li>This has to satisfy decryption correctness and security.
<ul>
<li>Decyrption Correctness: decryption of a ciphertext will return the encrypted message with probability <em>1 - negligible</em>.</li>
<li>Security: an adversary cannot obtain even partial information.</li>
</ul></li>
<li><strong>One wayness:</strong></li>
<li><strong>IND/EAV:</strong> and efficient adversary cannot determine which of two messages was encrypted knowing the public key and being able to encrypt ciphertexts (because the key is public).</li>
<li><strong>IND-CPA:</strong> the public key is public, so the adversary can do the encryption themself (but there is an oracle here). This is no stronger than IND.</li>
<li><strong>IND-CCA:</strong> this has the oracle (before and after seeing the challenge ciphertext, except not querying the challenge) with access to the secret key so it can decrypt. This is still pretty applicable in real life.</li>
<li><strong>IND-key-leakage:</strong> an intrusion can reveal part or all of the key.</li>
<li><strong>IND-key-dependent-plaintext:</strong> the message contains part or all of the key bits. This is harder than IND-CPA, and not really used.</li>
</ul>
<h2 id="rsa-again">RSA (again)</h2>
<ul>
<li>Texbook RSA is one-waynees secure (but not IND-CPA), but it is inefficient.</li>
<li>RSA can be broken by IND-CCA by flipping the bit.
<ul>
<li>Originally this was solved by adding a zero-knowledge proof, which behaves similar to MAC.</li>
</ul></li>
<li>Original RSA is deterministic. There's actually a lot of attacks.</li>
<li><strong>Padded RSA:</strong> this is insecure against IND-CCA.</li>
<li><strong>PKCS 1.5:</strong> this is insecure against short message attacks unless the randomness is at least half as large as the message (giving only IND-CPA).</li>
<li><strong>RSA OAEP:</strong> this is IND-CCA secure (<strong>but not adaptive IND-CCA</strong>). This is used in practice most of the time because it is efficient (ciphertexts are not too much longer than plaintexts, and computationally efficient.</li>
<li><strong>OAEP+:</strong> by Victor Shoup (of Courant). is adaptive IND-CCA secure. This is not used because the small extra security benefit is not enough to justify the costs</li>
</ul>
<h2 id="diffie-hellman">Diffie Hellman</h2>
<div class="subelem">

<h3 id="cyclic-groups-generators">Cyclic groups, Generators</h3>
<ul>
<li><strong>Subgroup:</strong> generated from an element in a larger set</li>
<li><code>&lt;g&gt;</code> a subgroup of G. The cardinality (order) is <em>g<sup>x</sup> = 1</em> for the smallest <em>x</em>. Since this is cyclic, there are mutliple values that exponentiate to the same output.</li>
</ul>
</div> <!-- End Subelem -->

<ul>
<li><strong>Discrete Logarithm Assumption:</strong> a logarithm (only over integers), over a generator group.</li>
<li>The best known algorithm to break this (number field sieve) is super-polynomial (but not exponential). With elliptic curves, number field sieve does not work, so there is only exponential time algorithms.</li>
<li>This is actually a one-way permutation, as the group is cyclic, so we don't actually invert the function to find the answer.</li>
<li><strong>Decisional Diffie Hellman Assumption:</strong> this is an indistinguishability problem, where an adversary cannot easily distinguish between (g, g<sup>x</sup>, g<sup>y</sup>, g<sup>xy</sup>) and (g, g<sup>x</sup>, g<sup>y</sup>, g<sup>z</sup>).</li>
<li><strong>ElGamal:</strong> A public key encryption scheme secure against IND-CPA. The ciphertext size is twice the plaintext size (this is good).
<ul>
<li><strong>Cramer-Shoup Scheme:</strong> extends El Gamal to be adaptive IND-CCA secure. There is a "lite" version that is non-adaptive IND-CCA secure.</li>
</ul></li>
</ul>
<div class="subelem">

<h2 id="new-directions-in-cryptography-by-whitman-diffie-and-martin-hellman"><em>New Directions in Cryptography</em> By Whitman Diffie and Martin Hellman</h2>
<p><a href="https://www.cs.jhu.edu/~rubin/courses/sp03/papers/diffie.hellman.pdf">Paper Link</a></p>
<ul>
<li>This paper attempts to show a solution for sharing private keys over a public/insecure channel, and using those same keys to create digital signatures. It seems like this isn't about actually building an encryption scheme like RSA.</li>
<li>This only looks for computationally secret solutions, given the only unconditionally secret solution is the one time pad, which is too expensive.</li>
<li><span class="comment">This paper is a really good introduction to cryptography.</span></li>
<li><strong>Identification of Friend or Foe (IFF):</strong> this is a chosen plaintext attack originating from WW2 when planes would get challenges and have to encrypt to prove they were friendly (or a foe could get a chosen plaintext/ciphertext pair).</li>
<li>They suggest creating a trusted server that authenticates each user when they give their public key. This allows every user trying to communicate with someone to authenticate them by getting the public key from the server.</li>
<li>DH only works if computing logarithms is hard. This was created because they were looking for a one way function.</li>
<li><span class="confused">Do they argue that <em>a<sup>x<sub>i</sub></sup></em> is the only thing that needs to be shared, or also <em>a</em> and <em>a<sup>x</sub>j</sub></sup></em>?</span></li>
<li>Digital signatures should be created by using one way functions that allow for public verification, but it is computationally infeasible to forge a message.</li>
<li>They argue it is okay for one-way functions to not be permutations, <span class="comment">which is so interesting! They are more focused on it being hard to invert (which make ssense).</span>
<ul>
<li>However, when generating cryptosystems from one way functions, they must be one-to-one.</li>
</ul></li>
<li><code>Public Key Cryptosystem -&gt; one-way authentication</code> and <code>Public Key Cryptosystem -&gt; Public Key Distribution System</code>, but the inverses are not true.</li>
<li><code>Public Key Cryptosystem = Trapdoor (one way) functions</code>. <code>Trapdoor cryptosystem -&gt; Public Key Distribution System</code></li>
<li><strong>Quasi One Way function:</strong> a trapdoor function where you do not know the trapdoor.</li>
<li>They argue that using NPC problems as cryptographic solutions could work (provided there is more research).</li>
</ul>
</div> <!-- End Subelem -->

<div class="subelem"> <!-- El Gamal -->

<h2 id="elgamal">ElGamal</h2>
<p><a href="https://link.springer.com/content/pdf/10.1007%2F3-540-39568-7_2.pdf">Link to paper</a></p>
</div> <!-- End Subelem (El Gamal) -->

</div>
<div class="lecture">

<h1 id="advanced-public-key-cryptography">Advanced Public Key Cryptography</h1>
<ul>
<li>This is how to use the public key constructions to encrypt large messages to make the schemes useful.</li>
</ul>
<h2 id="hybrid-encryption">Hybrid Encryption</h2>
<ul>
<li>We want performance similar to block ciphers (fast). In practice, we can get a performance speedup by using block ciphers.</li>
<li><strong>Hybrid Encryption:</strong> use public key encryption to send a private key. We can then use symmetric key cryptography with the private key for arbitrary length communication with incredible performance, including with people we do not know.</li>
<li>We can get IND-CPA by using a public key scheme satisfying IND-CPA, and a private key scheme satisfying IND. We only need IND because we only use the key once.</li>
<li>To get IND-CCA, both the public and private schemes need to satisfy IND-CCA.</li>
<li><strong>Key Encapsulation Method (KEM):</strong> a private key is shared using public key encryption (or other methods).</li>
</ul>
<h3 id="random-oracle">Random Oracle</h3>
<ul>
<li><strong>Random oracle model:</strong> using a hash function in the construction of the encryption method to make it behave like a random function. The hash function tries to act random in order to be collision resistant.</li>
<li>There are certain (currently unrealistic) schemes that are secure under the random oracle model (random generator), but insecure when replaced with a hash function. This is secure enough (provided the hash function is not broken).</li>
<li>KEMs in the random oracle model is more efficient than hybrid encryption. This is because they assume we don't need IND-CPA (there's only a short message).</li>
<li><strong>DDH KEM:</strong></li>
<li><strong>RSA KEM:</strong></li>
</ul>
<h2 id="homomorphic-and-malleable-encryption">Homomorphic and Malleable Encryption</h2>
<ul>
<li><strong>Homophobic Encryption:</strong> <code>damn the gays</code> is the key.</li>
<li>People are more worried about their data. What if we just computed on encrypted data?</li>
<li><strong>Homomorphic Encryption:</strong> multiple ciphertexts are combined, with a function that outputs a single plaintext as a result of the ciphertexts. <em>E(pk, m<sub>1</sub>) op E(pk, m<sub>2</sub>) = E(pk, m<sub>1</sub> + m<sub>2</sub>)</em>. We do not have a secret key!</li>
<li>ElGamal is product-homomorphic and product-malleable.</li>
<li><strong>Malleable Encryption:</strong> changes one ciphertext into another. The plaintext is a result of applying the function. <em>f(E(pk, m)) = E(pk, f(m))</em>.</li>
</ul>
<h4 id="revolutionary-schemes">Revolutionary Schemes</h4>
<ul>
<li><strong>Partial Homomorphism:</strong> the scheme can do sum, product, and/or xor homomorphism, but not all 3. This also means that composition of the operation cannot be done in arbitrary orders.</li>
<li><strong>Goldwasser-Micali:</strong> this is IND-CPA secure (first proved). Based on quadratic residue (Does <em>w</em> exist in <em>w<sup>2</sup> = y mod n</em>? Is \(\sqrt{y}\) an integer? is computationally infeasible). This encrypts a single bit with each residue, so it is very inefficient. This is xor-homomorphic.</li>
<li><strong>Rabin:</strong> based on hardness of modular square root (which is reducible to factoring). Satisfies one-wayness, but chosen ciphertext attacks leaks the entire secret key.
<ul>
<li><strong>Probabilistic Rabin:</strong> satisfies IND-CPA by using the LSB as a hard core predicate.</li>
<li>\(x^2\ mod\ n\) is a trapdoor function (and permutation if <em>n</em> is chosen correctly).</li>
</ul></li>
<li><strong>Paillier:</strong> Uses \(Z_{n^2}^*\), which gives: \(gcd(n, \phi (n)) = 1\), certain discrete logarithms, and \(Z_n \cdot Z_n^*\) is an isomorphism of \(Z_{n^2}^*\). This has hardness based on finding the nth-root of <em>y</em>. With high probability, there is not an nth-root (but this still works). This is the first sum-homomorphic, sum/product-malleable (if you know one value being added/multiplied).
<ul>
<li><span class="confused">If we know the value being added/multiplied and we know the result, can't we easily get the value (thereby leaking information)?</span></li>
<li>This scheme can be used for creating digital elections that allow for anyone to verify the results (sum homomorphism) without leaking information about the voters. The issue is that the trusted authority that counts the votes (a different trusted authority than the one who publishes the public key) might not be able to keep the information from the public key trusted authority.</li>
</ul></li>
<li><strong>Full Homomorphism:</strong> the scheme is both sum and product homomorphic, but in <em>an arbitrary composition order</em>.</li>
<li><strong>Arithmetic Circuts:</strong> a tree where variables are combined by using operations. Any polynomial time algorithm can be represented in arithmetic circuts (this is also true for boolean circuts (<strong>AND</strong>, <strong>XOR</strong>, OR, NOT)). Fully homomorphic schemes can represent their operations using this.</li>
<li><strong>Gentry:</strong> uses ideal latices, but too inefficient to be used in practice. This satisfies IND-CPA. <a href="https://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf">Link to paper</a>
<ol type="1">
<li>Somewhat homomorphism: uses simple decryption algorithm, masking ciphertexts using noise.</li>
<li>Bootstrapping: re-encryption in a homomorphic way. This is necessary because this ensures decryption correctness by dealing with the noise to maintain low enough noise.</li>
</ol></li>
<li><strong>DGHV:</strong> this is similar to Gentry, but has private key and public key (a transformation of the private key scheme) versions. Addition adds one bit of noise, but multiplication doubles the noise. This satisfies IND-CPA.</li>
<li><span class="confused">Why do we need decryption correctness (why is small error not okay)? Looking at other privacy methods for ensuring anonymity (randomized response, Laplace distributions), isn't error okay?</span></li>
<li>IND-CCA cannot be guaranteed because homomorphism and malleability helps break the schemes.</li>
</ul>
</div>

<div class="lecture">

<h1 id="digital-signatures">Digital Signatures</h1>
<h2 id="definitions">Definitions</h2>
<ul>
<li>Digital signatures are arguably stronger than hand written signatures, as it is nearly impossible to digital signature for another message, as compared to a normal signature.</li>
<li>Digital signatures are useful for data authenticity and integrity and is useful with advanced encryption.</li>
<li>Digital signatures are the essentially the public key version of MACs, in that they are also publicly verifiable, transferable. They are stronger than MACs in that provide non-repudiation.</li>
<li>Correctness:</li>
<li>Security: we again have existential unforgability under a chosen message attack. This runs the signature algorithm polynomial times as an oracle.</li>
<li><strong>Universal Forgeablity:</strong> an adversary can efficiently sign <em>any</em> message. This is useful for attackers, but we want a much stronger definition (existential unforgeability) for our schemes.</li>
<li>With security, encryption and signature algorithms have very different goals (indistinguishability versus unforgeability), so their security guarantees are different for related schemes.</li>
</ul>
<h2 id="number-theory-based-schemes">Number theory based schemes</h2>
<ul>
<li><strong>Textbook RSA signature:</strong> this decrypts the message with the secret key, allowing for verification to be the encryption with the public key. This can be forged by choosing two <em>arbitrary</em> messages, then taking their product for both the messages and signatures for both messages (this works because RSA is product homomorphic).</li>
<li><strong>RSA Full Domain Hash (RSA-FDH):</strong> this first hashes the message, then does the RSA decryption of it. This is existentially unforgeable under CMA if the hash function is secure. The hash has to return a value in all of <em>Z<sub>n</sub><sup>*</sup></em>, rather than the hash size.</li>
<li><strong>Hash and Sign:</strong> this works provided the length is bounded by the modulus. Given that we can make the hash a specific length, this works in the general case. The public key includes the key for the hash.</li>
<li><strong>Identification/User Authentication:</strong> the below scheme protects against passive (eavesdropping) and active (server intrusion, choose challenge) attacks.
<ol type="1">
<li>ID + proof setup</li>
<li>Random challenge</li>
<li>Proof answer given challenge</li>
</ol></li>
<li><span class="confused">What schemes are secure against active attacks? Does this essentially take an IND-CPA scheme and make it IND? And then because the attacker can do CMA, then they can fake a signature by flipping the bits?</span></li>
<li><strong>Schnorr:</strong> this is secure against passive attacks.</li>
<li><strong>Fiat-Shamir Transform:</strong> this changes an identification scheme into a signature scheme.</li>
<li><strong>ElGamal Signatures:</strong> this is the precursor to DSA.</li>
<li><strong>Digital Signature Algorithm (DSA):</strong> this uses ElGamal and the Fiat-Shamir transformation. This is secure given <em>F</em> is random (although it is not, but we haven't found attacks).</li>
<li><strong>Elliptic Curve DSA (ECDSA):</strong> a modification of DSA to use elliptic curves (q-order subgroup of elliptic curve group of <em>Z<sub>p</sub><sup>*</sup></em> instead of ElGamal properties (q-order subgroup of <em>Z<sub>p</sub><sup>*</sup></em>).</li>
<li><strong>Lamport's Scheme:</strong> this only requires collision intractible hash functions (this is an efficient one-way function, but any OWF works). This is fairly weak (one-time signature) because 2 or more CMA breaks the scheme.</li>
<li><strong>Stateful-Based:</strong> signer keeps state, generating a new pk, sk pair for each message. The length of public keys is related to the number of messages to be sent.</li>
<li><strong>Merkle Tree-Based:</strong> we can prove that each leaf (message) comes from the root. The public key must be regenerated each time a message is sent.</li>
<li><strong>Chain-based:</strong> this is relatively slow (O(t) signature length, state size, and verification time). Each signature reveals all messages previously signed.</li>
<li><strong>Tree-Based Lamport:</strong> generates part of a binary tree (similar to getting PRFs from PRG). Signs message with key at leaf. this is reasonably efficient (<em>O(log t)</em>). It is stateful but can be made stateless.</li>
</ul>
<div class="subelem"> <!-- ECC -->

<h3 id="elliptic-curves">Elliptic Curves</h3>
<ul>
<li>Take some prime <em>p</em>, then comput an elliptic curve group based on \(y^2=x^3+Ax+B\ mod\ p\). To have no repeated roots, \(4A^3+27B^2 \neq 0\ mod\ p\).</li>
<li>We can also get a third point from <em>R</em> from <em>P</em> and <em>Q</em>. <em>R</em> is another point on a line that spans through <em>P</em> and <em>Q</em>.</li>
<li>Elliptic Curves with the operation addition (compared to multiplicative groups) is an Abelian group.</li>
<li>Discrete log is now a multiplication problem: compute <em>x</em> from \(x \cdot P\). There are only exponential solutions (the others had subexponential).</li>
<li>There's about <em>P</em> points and they can be efficiently generated.</li>
<li>This is convenient because it allows for shorter keys (512 bits). All discrete logarithm problems (DH, ElGamal, etc. can be reformulated with ECC).</li>
</ul>
</div> <!-- End Subelem (ECC) -->

<h2 id="public-key-infrastructure">Public Key Infrastructure</h2>
<ul>
<li>This is how we trust that someone's public key is actually their public key. We create a trusted server/recognized authority to verify identities.</li>
<li>Certification Authority (CA): verifies identities, manages (gives/revokes) certificates and public keys.
<ol type="1">
<li>Generate public/secret keys.</li>
<li>Go to CA to have them verify your keys. This can be done by proving your identify, by going in person, decrypting/signing messages from the CA, or using zero-knowledge proofs.</li>
<li>Get messages from people.
<ul>
<li>They verify your identity by another channel. They must make sure it is valid, not expired, and not revoked.</li>
</ul></li>
<li>Decrypt your messages based on your secret key.</li>
</ol></li>
<li>Key Escrow: you have a special key where you can decrypt encrypted data (often requiring multiple parties each having a part of the secret key). This is so you can decrypt someone's messages (if someone forces you).</li>
<li>Zero Trust: limits permissions because even if you are in a PKI, you cannot compromise others.</li>
<li>Identity-Based Encryption: public key is any binary string that binds the user to it. A trusted server gives the user a secret key that allows them to decrypt messages sent to them. This is less popular than PKI.</li>
</ul>
<div class="subelem"> <!-- Merkle Hash trees -->

<h2 id="merkle-hash-tree-signature-scheme">Merkle Hash Tree Signature Scheme</h2>
<p><a href="http://merkle.com/papers/Thesis1979.pdf">link to paper</a></p>
</div> <!-- End Subelem (Merkle) -->

</div> <!-- End Lecture -->
</body>
</html>
